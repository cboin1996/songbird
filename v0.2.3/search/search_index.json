{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"songbirdcli \ud83d\udc26 Music Downloading Client Featuring mp3 or m4a Tagging","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Hello, and welcome to <code>songbirdcli</code>.</p> <p>Get started by installing the <code>songbirdcli</code> package</p> <pre><code>pip install songbirdcli\n</code></pre> <p>See the github repository for detailed installation instructions!</p>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>To view our API documentation, click here</p>"},{"location":"songbirdcli/cli/","title":"cli","text":""},{"location":"songbirdcli/cli/#songbirdcli.cli","title":"<code>songbirdcli.cli</code>","text":""},{"location":"songbirdcli/cli/#songbirdcli.cli.initialize_dirs","title":"<code>initialize_dirs(dirs)</code>","text":"<p>Initialize the apps directories</p> <p>Parameters:</p> <ul> <li> <code>dirs</code>             (<code>List[str]</code>)         \u2013          <p>the list of directories to initialize (create)</p> </li> </ul> Source code in <code>songbirdcli/cli.py</code> <pre><code>def initialize_dirs(dirs: List[str]):\n    \"\"\"Initialize the apps directories\n\n    Args:\n        dirs (List[str]): the list of directories to initialize (create)\n    \"\"\"\n    for _dir in dirs:\n        if not os.path.exists(_dir):\n            logger.info(f\"Creating dir: {_dir}\")\n            os.mkdir(_dir)\n</code></pre>"},{"location":"songbirdcli/cli/#songbirdcli.cli.resolve_mode","title":"<code>resolve_mode(inp, current_mode=modes.Modes.SONG)</code>","text":"<p>Resolve the mode based on a given mode, against the current mode</p> <p>Parameters:</p> <ul> <li> <code>inp</code>             (<code>str</code>)         \u2013          <p>user input</p> </li> <li> <code>current_mode</code>             (<code>Modes</code>, default:                 <code>SONG</code> )         \u2013          <p>The current mode of the app. Defaults to modes.Modes.SONG.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Modes]</code>         \u2013          <p>Optional[modes.Modes]: return the mode if the current mode needs to be changed, otherwise return nothing.</p> </li> </ul> Source code in <code>songbirdcli/cli.py</code> <pre><code>def resolve_mode(\n    inp: str, current_mode: modes.Modes = modes.Modes.SONG\n) -&gt; Optional[modes.Modes]:\n    \"\"\"Resolve the mode based on a given mode, against the current mode\n\n    Args:\n        inp (str): user input\n        current_mode (modes.Modes, optional): The current mode of the app. Defaults to modes.Modes.SONG.\n\n    Returns:\n        Optional[modes.Modes]: return the mode if the current mode needs to be changed, otherwise return nothing.\n    \"\"\"\n    try:\n        mode = modes.Modes(inp)\n        if mode != current_mode:\n            logger.info(f\"Switched to {mode.value} mode!\")\n            return mode\n        else:\n            return None\n    except ValueError:\n        return None\n</code></pre>"},{"location":"songbirdcli/cli/#songbirdcli.cli.run","title":"<code>run(config)</code>","text":"<p>main entrypoint for songbirdcli. Expects the songbirdcli config object.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>SongbirdCliConfig</code>)         \u2013          <p>songbirdcli settings pydantic model</p> </li> </ul> Source code in <code>songbirdcli/cli.py</code> <pre><code>def run(config: settings.SongbirdCliConfig):\n    \"\"\"main entrypoint for songbirdcli. Expects the songbirdcli config object.\n\n    Args:\n        config (settings.SongbirdCliConfig): songbirdcli settings pydantic model\n\n    \"\"\"\n    try:\n        common.set_logger_config_globally(log_level=config.log_level)\n        common.name_plate(entries=[f\"--cli {config.version}\"])\n        # only need folders on OS if we are running locally. Otherwise user is expected to provied folders\n        # via bind mounts\n        if config.run_local:\n            initialize_dirs(\n                [\n                    config.get_data_path(),\n                    config.get_itunes_folder_path(),\n                    config.get_itunes_lib_path(),\n                    config.get_gdrive_folder_path(),\n                    config.get_local_folder_path(),\n                ]\n            )\n        if not validate_essentials(config):\n            return None\n        current_mode = modes.Modes.SONG\n        while True:\n            logger.info(f\"---Songbird Main Menu v{config.version}\ud83d\udc26---\")\n\n            song_properties = None\n            album_song_properties = None\n            # launch album mode to collect songs\n            if current_mode == modes.Modes.ALBUM:\n                album_name = helpers.get_input(f\"Enter an album name.\", out_type=str)\n                # quit condition\n                if album_name is None:\n                    break\n                mode = resolve_mode(album_name, current_mode=current_mode)\n                # detect mode change and return to main menu\n                if mode is not None:\n                    current_mode = mode\n                    continue\n\n                album_song_properties = helpers.launch_album_mode(album_name)\n                if album_song_properties is None:\n                    break\n\n                songs = [song.trackName for song in album_song_properties]\n            elif current_mode == modes.Modes.SONG:\n                songs = helpers.get_input_list(\n                    \"Please input song(s), separated by ';'. E.g. song1; song2; song3.\",\n                    out_type=str,\n                    sep=\"; \",\n                )\n                # quit condition\n                if songs is None:\n                    break\n                mode = resolve_mode(songs[0], current_mode=current_mode)\n                # detect mode change and return to main menu\n                if mode is not None:\n                    current_mode = mode\n                    continue\n\n            logger.info(f\"Searching for songs: {songs}\")\n            for i, song in enumerate(songs):\n                if album_song_properties is not None:\n                    song_properties = album_song_properties[i]\n                success = run_for_song(config, song, song_properties)\n\n    except KeyboardInterrupt as e:\n        logger.info(\"\\nReceived keyboard interrupt :o\")\n\n    logger.info(\"Shutting down!\")\n</code></pre>"},{"location":"songbirdcli/cli/#songbirdcli.cli.run_download_process","title":"<code>run_download_process(file_path_no_format, youtube_home_url, youtube_search_url, youtube_query_payload, file_format, render_timeout, render_wait, render_retries, render_sleep)</code>","text":"<p>Download a song from youtube.</p> <p>Parameters:</p> <ul> <li> <code>file_path_no_format</code>             (<code>str</code>)         \u2013          <p>the absolute path of where to save the file (excluding file format)</p> </li> <li> <code>youtube_home_url</code>             (<code>str</code>)         \u2013          <p>the url to youtube's home page</p> </li> <li> <code>youtube_search_url</code>             (<code>str</code>)         \u2013          <p>the search url for youtube</p> </li> <li> <code>youtube_query_payload</code>             (<code>str</code>)         \u2013          <p>the query payload for youtube's search api</p> </li> <li> <code>file_format</code>             (<code>str</code>)         \u2013          <p>desired file format</p> </li> <li> <code>render_timeout</code>             (<code>int</code>)         \u2013          <p>amount of time before abandoning a render</p> </li> <li> <code>render_wait</code>             (<code>float</code>)         \u2013          <p>the amount of time before attempting a render</p> </li> <li> <code>render_retries</code>             (<code>int</code>)         \u2013          <p>the number of retries for a render</p> </li> <li> <code>render_sleep</code>             (<code>int</code>)         \u2013          <p>the amount of time to wait after rendering</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>the path on disk that the file was saved to. None if the download fails.</p> </li> </ul> Source code in <code>songbirdcli/cli.py</code> <pre><code>def run_download_process(\n    file_path_no_format: str,\n    youtube_home_url: str,\n    youtube_search_url: str,\n    youtube_query_payload: dict,\n    file_format: str,\n    render_timeout: int,\n    render_wait: float,\n    render_retries: int,\n    render_sleep: int,\n) -&gt; str:\n    \"\"\"Download a song from youtube.\n\n    Args:\n        file_path_no_format (str): the absolute path of where to save the file (excluding file format)\n        youtube_home_url (str): the url to youtube's home page\n        youtube_search_url (str): the search url for youtube\n        youtube_query_payload (str): the query payload for youtube's search api\n        file_format (str): desired file format\n        render_timeout (int): amount of time before abandoning a render\n        render_wait (float): the amount of time before attempting a render\n        render_retries (int): the number of retries for a render\n        render_sleep (int): the amount of time to wait after rendering\n\n    Returns:\n        str: the path on disk that the file was saved to. None if the download fails.\n    \"\"\"\n    # obtain video selection from user\n    video_url = helpers.get_input(\n        prompt=f\"Enter a URL, or hit enter to use '{youtube_query_payload}' as a query to youtube: \",\n        out_type=str,\n    )\n\n    if video_url is None:\n        return None\n\n    # empty str (enter) query youtube\n    if video_url == \"\":\n        link_list, links = youtube.get_video_links(\n            youtube_home_url,\n            youtube_search_url,\n            youtube_query_payload,\n            render_timeout,\n            render_wait,\n            render_retries,\n            render_sleep,\n        )\n\n        if link_list is None:\n            return\n\n        # Allow user to select the link they want to download\n        common.pretty_lst_printer(link_list)\n\n        video_selection_idx = helpers.select_items_from_list(\n            \"Select the song you wish to download!\",\n            link_list,\n            1,\n            return_value=False,\n        )\n        if video_selection_idx is None or len(video_selection_idx) == 0:\n            return None\n\n        video_url = youtube_home_url + links[video_selection_idx[0]].attrs[\"href\"]\n    # Process the download, and save locally\n    return youtube.run_download(video_url, file_path_no_format, file_format)\n</code></pre>"},{"location":"songbirdcli/cli/#songbirdcli.cli.run_for_song","title":"<code>run_for_song(config, song_name, song_properties)</code>","text":"<p>Run a cycle of the application given a song.</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>SongbirdConfig</code>)         \u2013          <p>the songbird config</p> </li> <li> <code>song_name</code>             (<code>str</code>)         \u2013          <p>the name of the song to run the app for</p> </li> <li> <code>song_properties</code>             (<code>Optional[ItunesApiSongModel]</code>)         \u2013          <p>optionally include song properties. Including these skips the itunes api parser.</p> </li> </ul> Source code in <code>songbirdcli/cli.py</code> <pre><code>def run_for_song(\n    config: settings.SongbirdCliConfig,\n    song_name: str,\n    song_properties: Optional[itunes_api.ItunesApiSongModel],\n):\n    \"\"\"Run a cycle of the application given a song.\n\n    Args:\n        config (settings.SongbirdConfig): the songbird config\n        song_name (str): the name of the song to run the app for\n        song_properties (Optional[itunes_api.ItunesApiSongModel]): optionally include song properties. Including these skips the itunes api parser.\n    \"\"\"\n    logger.info(f\"Searching for: {song_name}\")\n    file_itunes = []\n    file_gdrive = []\n    # itunes craves m4a formatted files. Otherwise we use mp3s, as were civilized people.\n    file_format = config.file_format if not config.itunes_enabled else \"m4a\"\n    # check if song exists locally in dump folder\n    file_local = common.find_file(config.get_local_folder_path(), f\"*{song_name}*\")\n    # check if song exists locally in itunes\n    if config.itunes_enabled:\n        file_itunes = itunes.itunes_lib_search(config.get_itunes_lib_path(), song_name)\n    # check if song exists locally in google drive folder\n    if config.gdrive_enabled:\n        file_gdrive = common.find_file(\n            config.get_gdrive_folder_path(), f\"*{song_name}*\"\n        )\n    # if any of the above, ask user if they want to download anyways\n    files = file_local + file_itunes + file_gdrive\n    if len(files) &gt; 0:\n        logger.info(\"Found the following similar files:\")\n        common.pretty_lst_printer(files)\n        inp = helpers.get_input(\n            \"Do you want to proceed with download anyway?\", choices=[\"y\", \"n\"]\n        )\n\n        if inp is None or inp == \"n\":\n            return\n\n    if song_properties is None:\n        song_properties = helpers.parse_itunes_search_api(song_name, modes.Modes.SONG)\n\n    if song_properties is None:\n        return\n\n    file_path_no_format = os.path.join(config.get_local_folder_path(), song_name)\n    file_path = file_path_no_format + \".\" + file_format\n    downloaded_file_path = None\n    # make sure file doesnt already exist\n    duped_filepath = common.fname_duper(file_path, config.fname_dup_limit, 1, \"_dup\")\n    if duped_filepath is None:\n        return\n    if duped_filepath != file_path:\n        logger.warning(\n            f\"Duplicate file(s) already exist for base file {file_path}, so I generated a new filename {duped_filepath}!\"\n        )\n        file_path_no_format = os.path.splitext(duped_filepath)[0]\n        file_path = duped_filepath\n    # run the youtube downloader\n    if config.youtube_dl_enabled:\n        payload = config.youtube_searchform_payload\n        # if song_properties is False, user selected no properties\n        if song_properties != False:\n            payload[config.youtube_search_tag] = (\n                f\"{song_properties.artistName} {song_properties.trackName}\"\n            )\n        else:\n            payload[config.youtube_search_tag] = song_name\n\n        downloaded_file_path = run_download_process(\n            file_path_no_format=file_path_no_format,\n            youtube_home_url=config.youtube_home_url,\n            youtube_search_url=config.youtube_search_url,\n            youtube_query_payload=payload,\n            file_format=file_format,\n            render_timeout=config.youtube_render_timeout,\n            render_wait=config.youtube_render_wait,\n            render_retries=config.youtube_render_retries,\n            render_sleep=config.youtube_render_sleep,\n        )\n\n    if downloaded_file_path is None:\n        return\n\n    if song_properties != False:\n        # tag file if user specified song properties\n        tag_successful = False\n        if file_format == \"mp3\":\n            tag_successful = itunes.mp3ID3Tagger(downloaded_file_path, song_properties)\n        elif file_format == \"m4a\":\n            tag_successful = itunes.m4a_tagger(downloaded_file_path, song_properties)\n        else:\n            logger.warning(\n                \"You've specified a file format that is has no tagger supported yet. Saving file without tags.\"\n            )\n\n    # provide user with choices for where to save their file to.\n    save_prompt_base = \"Would you like to save your file to\"\n    if config.itunes_enabled and config.gdrive_enabled:\n        inp = helpers.get_input(\n            save_prompt_base + \" gdrive (g), itunes (i), or locally (l)\",\n            out_type=str,\n            choices=[\"g\", \"i\", \"l\"],\n        )\n\n    if config.itunes_enabled and not config.gdrive_enabled:\n        inp = helpers.get_input(\n            save_prompt_base + \" itunes (i), or locally (l)\",\n            out_type=str,\n            choices=[\"i\", \"l\"],\n        )\n\n    if not config.itunes_enabled and config.gdrive_enabled:\n        inp = helpers.get_input(\n            save_prompt_base + \" gdrive (g), or locally (l)\",\n            out_type=str,\n            choices=[\"g\", \"l\"],\n        )\n\n    if not config.itunes_enabled and not config.gdrive_enabled:\n        inp = \"l\"\n\n    if inp is None:\n        return\n\n    if inp == \"i\":\n        msg = \"Saved to itunes\"\n        itunes_dest_path = common.fname_duper(\n            os.path.join(\n                config.get_itunes_folder_path(), os.path.basename(downloaded_file_path)\n            ),\n            config.fname_dup_limit,\n            1,\n            config.fname_dup_key,\n        )\n        if itunes_dest_path is None:\n            return None\n        shutil.move(downloaded_file_path, itunes_dest_path)\n    elif inp == \"g\":\n        msg = \"Saved to gdrive\"\n        gdrive_dest_path = common.fname_duper(\n            os.path.join(\n                config.get_gdrive_folder_path(), os.path.basename(downloaded_file_path)\n            ),\n            config.fname_dup_limit,\n            1,\n            config.fname_dup_key,\n        )\n        if gdrive_dest_path is None:\n            return None\n        shutil.move(downloaded_file_path, gdrive_dest_path)\n        # If running in a container, we need to provide a bind address\n        # Users are expected to run the container with hostname songbird (--hostname songbird)\n        bind_addr = None\n        if not config.run_local:\n            bind_addr = \"songbird\"\n        gdrive.save_song(\n            config.gdrive_folder_id,\n            credentials_path=os.path.join(\n                config.get_gdrive_folder_path(), \"credentials.json\"\n            ),\n            token_path=os.path.join(config.get_gdrive_folder_path(), \"token.json\"),\n            song_name=f\"{song_name}.{file_format}\",\n            song_path=str(gdrive_dest_path),\n            auth_port=config.gdrive_auth_port,\n            bind_addr=bind_addr,\n        )\n    else:\n        msg = \"Saved locally.\"\n\n    logger.info(msg)\n    return True\n</code></pre>"},{"location":"songbirdcli/cli/#songbirdcli.cli.validate_essentials","title":"<code>validate_essentials(config)</code>","text":"<p>perform startup validation of the configuration, ensuring pre-conditions are met</p> <p>Parameters:</p> <ul> <li> <code>config</code>             (<code>SongbirdCliConfig</code>)         \u2013          <p>the songbirdcli pydantic model</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code> (            <code>bool</code> )        \u2013          <p>True if success, False otherwise</p> </li> </ul> Source code in <code>songbirdcli/cli.py</code> <pre><code>def validate_essentials(config: settings.SongbirdCliConfig) -&gt; bool:\n    \"\"\"perform startup validation of the configuration,\n    ensuring pre-conditions are met\n\n    Args:\n        config (settings.SongbirdCliConfig): the songbirdcli pydantic model\n\n    Returns:\n        bool: True if success, False otherwise\n    \"\"\"\n    success = True\n    if config.gdrive_enabled:\n        if not os.path.exists(config.get_gdrive_folder_path()):\n            logger.error(\n                f\"You must create the path {config.get_gdrive_folder_path()} \\\n             to use google drive feature! If using docker, use bind mounts. See README for more info.\"\n            )\n            success = False\n        if not os.path.exists(\n            os.path.join(config.get_gdrive_folder_path(), \"credentials.json\")\n        ):\n            logger.error(\n                f\"You must provide a credentials.json file inside of {config.get_gdrive_folder_path()} to use gdrive feature!\"\n            )\n            success = False\n\n    if config.itunes_enabled:\n        if not os.path.exists(config.get_itunes_folder_path()):\n            logger.error(\n                f\"You must create the path {config.get_itunes_folder_path()} \\\n             to use itunes feature! If using docker, use bind mounts. See README for more info.\"\n            )\n            success = False\n\n        if not os.path.exists(config.get_itunes_lib_path()):\n            logger.error(\n                f\"You must create the path {config.get_itunes_lib_path()} \\\n             to use itunes feature! If using docker, use bind mounts. See README for more info.\"\n            )\n            success = False\n\n    if not os.path.exists(config.get_data_path()):\n        logger.error(\n            f\"At minimum, you need path {config.get_data_path()} configured to run the app. If using docker, use bind mounts. See README.\"\n        )\n    return success\n</code></pre>"},{"location":"songbirdcli/helpers/","title":"helpers","text":""},{"location":"songbirdcli/helpers/#songbirdcli.helpers","title":"<code>songbirdcli.helpers</code>","text":"<p>helpers.py module for helping with parsing inputs</p>"},{"location":"songbirdcli/helpers/#songbirdcli.helpers.get_input","title":"<code>get_input(prompt, out_type=None, quit_str='q', choices=None)</code>","text":"<p>Given a prompt, get input from stdio and perform basic type validation</p> <p>Parameters:</p> <ul> <li> <code>prompt</code>             (<code>str</code>)         \u2013          <p>the prompt to use</p> </li> <li> <code>out_type</code>             (<code>type</code>, default:                 <code>None</code> )         \u2013          <p>expected type for input. Defaults to None.</p> </li> <li> <code>quit_str</code>             (<code>str</code>, default:                 <code>'q'</code> )         \u2013          <p>a character to signify quitting from the input gatherer. Defaults to \"q\".</p> </li> <li> <code>choices</code>             (<code>Optional[List]</code>, default:                 <code>None</code> )         \u2013          <p>valid character options to parse as input. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Any]</code>         \u2013          <p>Optional[Any]: the typed user input, or None if quit or invalid type received.</p> </li> </ul> Source code in <code>songbirdcli/helpers.py</code> <pre><code>def get_input(\n    prompt: str, out_type=None, quit_str=\"q\", choices: Optional[List] = None\n) -&gt; Optional[Any]:\n    \"\"\"Given a prompt, get input from stdio and perform basic type validation\n\n    Args:\n        prompt (str): the prompt to use\n        out_type (type, optional): expected type for input. Defaults to None.\n        quit_str (str, optional): a character to signify quitting from the input gatherer. Defaults to \"q\".\n        choices (Optional[List], optional): valid character options to parse as input. Defaults to None.\n\n    Returns:\n        Optional[Any]: the typed user input, or None if quit or invalid type received.\n    \"\"\"\n    while True:\n        built_prompt = prompt\n        if choices is not None:\n            built_prompt += f\" , choices=({choices})\"\n        built_prompt += \" ['q' quits]: \"\n        inp = input(built_prompt)\n        if inp == quit_str:\n            return None\n\n        # initialize type to be empty by default\n        typed = None\n        if out_type is not None:\n            try:\n                typed = out_type(inp)\n\n            except ValueError as e:\n                logger.error(\n                    \"Invalid type received. Try again, inputting an '{out_type}'\"\n                )\n        else:\n            typed = inp\n\n        if choices is None:\n            return typed\n\n        if typed not in choices:\n            logger.error(f\"You must input one of {choices}\")\n        else:\n            return typed\n</code></pre>"},{"location":"songbirdcli/helpers/#songbirdcli.helpers.get_input_list","title":"<code>get_input_list(prompt, sep, out_type=int, quit_str='q')</code>","text":"<p>Take an input prompt, and generate a typed list from it, validating against the given input type.</p> <p>Parameters:</p> <ul> <li> <code>prompt</code>             (<code>str</code>)         \u2013          <p>the prompt to display to the user</p> </li> <li> <code>sep</code>             (<code>str</code>)         \u2013          <p>the expected separator in the input list</p> </li> <li> <code>out_type</code>             (<code>_type_</code>, default:                 <code>int</code> )         \u2013          <p>The expected data type. Defaults to int.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>If the input does not match the given type.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[int]</code>         \u2013          <p>Optional[List[int]]: the typed list, or None if user quit</p> </li> </ul> Source code in <code>songbirdcli/helpers.py</code> <pre><code>def get_input_list(prompt: str, sep: str, out_type=int, quit_str=\"q\") -&gt; List[int]:\n    \"\"\"Take an input prompt, and generate a typed list from it, validating against the given input type.\n\n    Args:\n        prompt (str): the prompt to display to the user\n        sep (str): the expected separator in the input list\n        out_type (_type_, optional): The expected data type. Defaults to int.\n\n    Raises:\n        ValueError: If the input does not match the given type.\n\n    Returns:\n        Optional[List[int]]: the typed list, or None if user quit\n    \"\"\"\n    while True:\n        inp = input(prompt + f\" ['{quit_str}' quits]: \")\n        if inp == quit_str:\n            return None\n\n        str_list = inp.split(sep)\n        typed_list = []\n        # by default fail type check\n        type_check_passed = False\n        for item in str_list:\n            type_check_passed = True\n            try:\n                typed_inp = out_type(item)\n            except ValueError as e:\n                logger.error(\n                    f\"Invalid input {inp} recieved, expected list with types: {out_type}, separated by '{sep}'\"\n                )\n                type_check_passed = False\n                break\n\n            typed_list.append(out_type(item))\n\n        # only exit loop if the type check has passed\n        if type_check_passed:\n            break\n    return typed_list\n</code></pre>"},{"location":"songbirdcli/helpers/#songbirdcli.helpers.launch_album_mode","title":"<code>launch_album_mode(artist_album_string='')</code>","text":"<p>Parameters:</p> <ul> <li> <code>artist_album_string</code>             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>the album/artist to search for.</p> </li> </ul> <p>Returns: the list of song properties gathered from the search.</p> Source code in <code>songbirdcli/helpers.py</code> <pre><code>def launch_album_mode(artist_album_string=\"\"):\n    \"\"\"\n    Args:\n        artist_album_string (str): the album/artist to search for.\n\n    Returns: the list of song properties gathered from the search.\n\n    \"\"\"\n    while True:\n        album_props = parse_itunes_search_api(\n            search_variable=artist_album_string, mode=modes.Modes.ALBUM, lookup=False\n        )\n        # check if user quit\n        if album_props is None:\n            return None\n\n        # get the song matching the album metadata\n        songs_in_album_props = itunes.query_api(\n            search_variable=album_props.collectionId,  # get list of songs for chosen album\n            limit=album_props.trackCount,\n            mode=modes.Modes.SONG,\n            lookup=True,\n        )\n        if songs_in_album_props == None:\n            logger.error(\"Sorry. Cant seem to find any details for this album!\")\n\n        songs_in_album_props = remove_songs_selected(\n            song_properties_list=songs_in_album_props\n        )\n        if songs_in_album_props is None:\n            return None\n\n        return songs_in_album_props\n</code></pre>"},{"location":"songbirdcli/helpers/#songbirdcli.helpers.parse_itunes_search_api","title":"<code>parse_itunes_search_api(search_variable, mode, limit=20, lookup=False)</code>","text":"<p>perform a query of the items api, allowing user to select an item from the returned list of options</p> <p>Parameters:</p> <ul> <li> <code>search_variable</code>             (<code>str</code>)         \u2013          <p>the value for the query</p> </li> <li> <code>mode</code>             (<code>Modes</code>)         \u2013          <p>the mode to run</p> </li> <li> <code>limit</code>             (<code>int</code>, default:                 <code>20</code> )         \u2013          <p>number of results. Defaults to 20.</p> </li> <li> <code>lookup</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>whether to enable 'lookup' mode in itunes api. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Union[bool, ItunesApiSongModel]]</code>         \u2013          <p>Optional[Union[itunes_api.ItunesApiSongModel]]: returns the selected song properties, a bool=False if use continues without selection, or None if the user quits or an error occurred.</p> </li> </ul> Source code in <code>songbirdcli/helpers.py</code> <pre><code>def parse_itunes_search_api(\n    search_variable: str, mode: modes.Modes, limit: int = 20, lookup: bool = False\n) -&gt; Optional[Union[bool, itunes_api.ItunesApiSongModel]]:\n    \"\"\"perform a query of the items api, allowing user to select\n    an item from the returned list of options\n\n    Args:\n        search_variable (str): the value for the query\n        mode (modes.Modes): the mode to run\n        limit (int, optional): number of results. Defaults to 20.\n        lookup (bool, optional): whether to enable 'lookup' mode in itunes api. Defaults to False.\n\n    Returns:\n        Optional[Union[itunes_api.ItunesApiSongModel]]: returns the selected song properties, a bool=False if use continues without selection, or None if the user quits or an error occurred.\n    \"\"\"\n    parsed_results_list = itunes.query_api(search_variable, limit, mode, lookup=lookup)\n\n    # Present results to user\n    common.pretty_list_of_basemodel_printer(parsed_results_list)\n    logger.info(\"Searched for: %s\" % (search_variable))\n    # Only one item can be selected\n    user_selection = select_items_from_list(\n        \"Select the number for the properties you want\",\n        parsed_results_list,\n        1,\n        no_selection_value=-1,\n    )\n\n    # user has quit\n    if user_selection is None:\n        logger.info(\"Quitting.\")\n        return\n    if len(user_selection) == 0:\n        logger.info(\"Continuing without properties.\")\n        return False\n\n    print(f\"Selected item: \")\n    for k, v in user_selection[0].model_dump().items():\n        print(\" - %s : %s\" % (k, v))\n\n    return user_selection[0]\n</code></pre>"},{"location":"songbirdcli/helpers/#songbirdcli.helpers.remove_songs_selected","title":"<code>remove_songs_selected(song_properties_list)</code>","text":"<p>Given a list of songs properties, allow the user to remove via stdio</p> <p>Parameters:</p> <ul> <li> <code>song_properties_list</code>             (<code>Any</code>)         \u2013          <p>the list of song properties</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[List]</code>         \u2013          <p>Optional[List]: the properties list after selection</p> </li> </ul> Source code in <code>songbirdcli/helpers.py</code> <pre><code>def remove_songs_selected(song_properties_list) -&gt; Optional[List]:\n    \"\"\"Given a list of songs properties, allow the user to remove\n    via stdio\n\n    Args:\n        song_properties_list (Any): the list of song properties\n\n    Returns:\n        Optional[List]: the properties list after selection\n    \"\"\"\n    common.pretty_list_of_basemodel_printer(song_properties_list)\n    input_string = \"Enter song id's (1 4 5 etc.) you dont want from this album\"\n    user_input = select_items_from_list(\n        input_string,\n        song_properties_list,\n        n_choices=len(song_properties_list) - 1,\n        sep=\" \",\n        opposite=True,\n        no_selection_value=-1,\n    )\n    # user has quit\n    if user_input == None:\n        return None\n    # user selects all songs\n    if user_input == []:\n        return song_properties_list\n    # otherwise, user gets the processed list with their items removed\n    return user_input\n</code></pre>"},{"location":"songbirdcli/helpers/#songbirdcli.helpers.select_items_from_list","title":"<code>select_items_from_list(prompt, lyst, n_choices, sep=None, quit_str='q', opposite=False, no_selection_value=None, return_value=True)</code>","text":"<p>Input validation against a list.</p> <p>Parameters:</p> <ul> <li> <code>prompt</code>             (<code>str</code>)         \u2013          <p>prompt to display to user</p> </li> <li> <code>sep</code>             (<code>   (str</code>, default:                 <code>None</code> )         \u2013          <p>the separator for the input</p> </li> <li> <code>lyst</code>             (<code>List</code>)         \u2013          <p>the list to perform input validation against</p> </li> <li> <code>n_choices</code>             (<code>int</code>)         \u2013          <p>the number of choices allowed</p> </li> <li> <code>quit_str</code>             (<code>str</code>, default:                 <code>'q'</code> )         \u2013          <p>The string to cancel validation and exit. Defaults to \"q\".</p> </li> <li> <code>opposite</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>return everything BUT the user selection</p> </li> <li> <code>no_selection_value</code>             (<code>any</code>, default:                 <code>None</code> )         \u2013          <p>value to indicate no selection wanted from the user</p> </li> <li> <code>return_value</code>             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>if true, return the value, otherwise return the indicies of selections</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List</code>         \u2013          <p>Optiona[List]: None if user quits, [] if user selects nothing, otherwise a list of the users selections are returned.</p> </li> </ul> Source code in <code>songbirdcli/helpers.py</code> <pre><code>def select_items_from_list(\n    prompt: str,\n    lyst: List,\n    n_choices: int,\n    sep: Optional[str] = None,\n    quit_str: str = \"q\",\n    opposite: bool = False,\n    no_selection_value=None,\n    return_value: bool = True,\n) -&gt; List:\n    \"\"\"Input validation against a list.\n\n    Args:\n        prompt (str): prompt to display to user\n        sep    (str): the separator for the input\n        lyst (List): the list to perform input validation against\n        n_choices (int): the number of choices allowed\n        quit_str (str): The string to cancel validation and exit. Defaults to \"q\".\n        opposite (bool): return everything BUT the user selection\n        no_selection_value (any): value to indicate no selection wanted from the user\n        return_value (bool): if true, return the value, otherwise return the indicies of selections\n\n    Returns:\n        Optiona[List]: None if user quits, [] if user selects nothing, otherwise a list of the users selections are returned.\n    \"\"\"\n    tries = 0\n    low = 0\n    high = len(lyst) - 1\n    # provide useful ranges to user\n    if high == -1:\n        range_display = \"\"\n    elif high == 0:\n        range_display = f\" (choose {high})\"\n    else:\n        range_display = f\" (choose {low} to {high}) \"\n    # fill appropriate prompt based on opposite feature\n    if opposite:\n        opposite_prompt = \" select all\"\n    else:\n        opposite_prompt = \" continue without selection\"\n\n    if no_selection_value is None:\n        no_selection_prompt = \"\"\n    else:\n        no_selection_prompt = f\"[{no_selection_value} {opposite_prompt}]\"\n\n    while True:\n        tries += 1\n        if tries &gt; 5:\n            logger.info(f\"Wtf man. {tries} tries so far? Just get it right!\")\n        # get user input\n        inp = get_input_list(\n            prompt + f\"{range_display} {no_selection_prompt}\",\n            sep,\n            out_type=int,\n        )\n        if inp is None:\n            return None\n        if len(inp) == 0:\n            logger.info(\"You selected nothing.\")\n            return []\n        # verify if the value of the input is the selection value\n        if inp[0] == no_selection_value:\n            return []\n        # if user has entered too many choices, try again!!\n        if len(inp) &gt; n_choices:\n            logger.error(f\"You're only allowed {n_choices} here. Try again.\")\n            continue\n        # user has passed validation, now check the values are reasonable\n\n        boundary_check_passed = True\n        for val in inp:\n            if val &gt; high or val &lt; low:\n                logger.error(\n                    f\"Sorry, the value {val} is out of bounds. Please enter within the interval [{low}, {high}]\"\n                )\n                boundary_check_passed = False\n        if not boundary_check_passed:\n            continue\n\n        # if user gets passed all of above, actually select values or indices at this point, and return\n        if not opposite:\n            result = []\n            for val in inp:\n                if return_value:\n                    result.append(lyst[val])\n                else:\n                    result.append(val)\n        else:\n            result = []\n            for idx in range(len(lyst)):\n                if idx not in inp:\n                    if return_value:\n                        result.append(lyst[idx])\n                    else:\n                        result.append(idx)\n        return result\n</code></pre>"},{"location":"songbirdcli/settings/","title":"settings","text":""},{"location":"songbirdcli/settings/#songbirdcli.settings","title":"<code>songbirdcli.settings</code>","text":""},{"location":"songbirdcli/settings/#songbirdcli.settings.SongbirdCliConfig","title":"<code>SongbirdCliConfig</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Configuration using .env file or defaults declared in here</p>"},{"location":"songbirdcli/settings/#songbirdcli.settings.SongbirdCliConfig.get_itunes_folder_path","title":"<code>get_itunes_folder_path()</code>","text":"<p>If you run the app locally, configure the itunes path as an absolute path. Otherwise, the program will use the local container storage and assume to be running in a docker container.</p> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>the path to where itunes destined songs should live</p> </li> </ul> Source code in <code>songbirdcli/settings.py</code> <pre><code>def get_itunes_folder_path(self) -&gt; str:\n    \"\"\"If you run the app locally, configure the itunes path as an absolute path. Otherwise, the program will\n    use the local container storage and assume to be running in a docker container.\n\n    Returns:\n        str: the path to where itunes destined songs should live\n    \"\"\"\n    if self.run_local:\n        return self.itunes_folder_path\n    return os.path.join(self.get_data_path(), self.itunes_folder_path)\n</code></pre>"},{"location":"songbirdcli/settings/#songbirdcli.settings.SongbirdCliConfig.get_itunes_lib_path","title":"<code>get_itunes_lib_path()</code>","text":"<p>If you run the app locally, configure the itunes path as an absolute path. Otherwise, the program will use the local container storage and assume to be running in a docker container.</p> <p>Returns:</p> <ul> <li> <code>str</code> (            <code>str</code> )        \u2013          <p>the path to where itunes destined songs should live</p> </li> </ul> Source code in <code>songbirdcli/settings.py</code> <pre><code>def get_itunes_lib_path(self) -&gt; str:\n    \"\"\"If you run the app locally, configure the itunes path as an absolute path. Otherwise, the program will\n    use the local container storage and assume to be running in a docker container.\n\n    Returns:\n        str: the path to where itunes destined songs should live\n    \"\"\"\n    if self.run_local:\n        return self.itunes_lib_path\n    return os.path.join(self.get_data_path(), self.itunes_lib_path)\n</code></pre>"},{"location":"songbirdcli/settings/#songbirdcli.settings.SongbirdServerConfig","title":"<code>SongbirdServerConfig</code>","text":"<p>             Bases: <code>BaseSettings</code></p> <p>Configuration using .env file or defaults declared in here</p>"}]}